Интерпретатор языка HSE SCHEME (аналог [MIT SCHEME](https://ru.wikipedia.org/wiki/MIT/GNU_Scheme)). Это Lisp подобный язык, интерпретатор написан на языке С++.

Интерпретатор поддерживает стандартные арифметические функции, кортежи любого размера, лямбда функции, функции для работы с кортежами и примитивные типы.

## Базовые типы и функции над ними

Давайте разберем стандартные конструкции, например сложим два числа

```scheme
$ (+ 1 2)
> 3
```

Аналогично можно вычесть, умножить и поделить. Также поддержаны логические операции и операции сравнения

```scheme
$ (or #f #f #f)
> #f

$ (and (= 2 2) (> 2 1))
> #t
```

Можно заметить, что true обозначается через `#t`, а false через `#f`.

## If

У условного оператора доступно 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`

Сначала вычисляет `condition` и проверяет значение на истинность. Затем вычисляет либо `true-branch`, либо `false-branch` и возвращает как результат всего `if`-а.

Пример

```scheme
$ (+ 1 (if #f 0 1))
> 2
```

## Переменные

Поддержка переменных реализована с помощью особых форм `define` и `set!`.

```scheme
$ (define x 1)
> ()
$ x
> 1
```

Обратите внимание на возвращаемое значение `define`. Команда `set!` используется для изменения значения **существующей**
переменной:

```scheme
$ (define x 1)
> ()
$ (set! x 2)
$ x
> 2
$ (set! y 1)
> NameError
```

## Особая форма quote

В языке существует операция `quote`, которая при вычислении просто возвращает свой аргумент, например

```scheme
$ (quote 1)
> 1

$ (quote (+ 1 2))
> (+ 1 2)
```

Также поддерживается специальный токен `'` - это синтаксический сахар для `quote`. То есть, `'1` = `(quote 1)`, `'(1 2)` = `(quote (1 2))` и так далее.

Примеры использования:

```scheme
$ '(+ 1 2)
> (+ 1 2)

$ (quote (quote 1))
> (quote 1)

$ (quote '1)
> (quote 1)
```

Особая форма нужна для удобства объявления переменных и присваивания в них кортежей. Мы не можем просто присвоить кортеж,
это будет синтаксической ошбибкой.

```scheme
$ (define x (1 2))
> RuntimeError
```

Но если вычислить кортеж в себя, то ошибкой это уже не будет

```scheme
$ (define x '(1 2))
$ x
> (1 2)
```

## Кортежи

Кортежи реализованы в виде пары двух значений. То есть кортеж `(1 2 3)` раскроется в пару `(1, (2, 3))`, где второй аргумент тоже пара.

Еще есть особые формы `set-car!` и `set-cdr!` - для работы с кортежами. `set-car!` присваивает в первый элемент пары любое значение, а
`set-cdr!` во второй элемент.

```scheme
$ (define x '(1 2))
$ (set-car! x 5)
$ x
> (5 2)
```

В этом пункте есть значительное отличие от MIT SCHEME, в нашем языке кортеж может рекурсивно ссылаться на себя, в отличие от MIT SCHEME.

## Лямбда-функции

Синтаксис:

* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda (x) (set! x (* x 2)) (+ 1 x))`
* `(lambda () 1)`

Создаёт новую функцию. Сначала перечисляется список аргументов функции, затем её тело. Тело может состоять из нескольких выражений, в этом случае они вычисляются по порядку а результат последнего выражения становится результатом функции.

Запись `(define (fn-name <args>) <body>)` эквивалентна `(define fn-name (lambda (<args>) <body>))`. То есть, запись `(define (inc x) (+ x 1))` создаёт новую функцию `inc`.

Пример

```scheme
$ (define (inc x) (+ x 1))
$ (inc 5)
> 6
```

## Захват контекста

### Lambda capture in C++

Также возможен и захват контекста. Синтаксис примерно совпадает с C++:

```c++
auto Range(int x) {
  return [&x] () {
    ++x;
    return x;
  };
}

void F() {
  auto r = Range(10);

  std::cout << r() << std::endl; // 11
  std::cout << r() << std::endl; // 12
}
```

В **Scheme**:

```scheme
$ (define range
    (lambda (x)
      (lambda ()
        (set! x (+ x 1))
        x)))

$ (define my-range (range 10))

$ (my-range)
> 11

$ (my-range)
> 12
```

Заметьте, что такой код на С++ содержит UB - ссылка на `x` становится висящей после выхода из `Range()`. В Scheme такого не происходит - объект будет жить, пока на него кто-либо ссылается. Вложенных scope может быть сколь угодно много.

### Сборщик мусора

Язык отслеживает все выделения переменных и захваты контекста, строит граф зависимостей и как только какие-то объекты становятся не нужными - чистит их. Поэтому язык защещен от утечек памяти.

### Запуск интерпретатора

Чтобы собрать интерпретатор склонируйте репозиторий и запустите из корня эти команды

```sh
mkdir build
cd build
cmake ..
make scheme
./scheme
```
